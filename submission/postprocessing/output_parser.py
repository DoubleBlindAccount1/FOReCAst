import os
import json
import re
import random
import datetime
import glob

class OutputParser:
    """
    A professional, extensible parser for model outputs in .jsonl files. This class extracts value and confidence fields from
    generated model outputs, with robust fallback logic and extensive documentation for clarity and maintainability.
    """
    @staticmethod
    def extract_value_confidence(question_type: str, prompt: str, generated_text: str) -> dict:
        """
        Extract the 'value' and 'confidence' fields from the generated model output text.
        If extraction fails, assign a random plausible value and confidence based on the question type.
        Args:
            question_type (str): The type of question (e.g., 'numeric', 'date', 'binary').
            prompt (str): The prompt string used for the model.
            generated_text (str): The raw output text generated by the model.
        Returns:
            dict: Dictionary with 'value' and 'confidence' fields.
        """
        # Attempt to remove the prompt from the generated text, if present
        prompt_end_idx = generated_text.find(prompt.strip())
        if prompt_end_idx != -1:
            generated_text = generated_text[prompt_end_idx + len(prompt):].strip()
        # Use regular expressions to extract value and confidence
        value_pattern = re.search(r'"value"\s*:\s*("[^"]+"|\d+\.?\d*)', generated_text)
        confidence_pattern = re.search(r'"confidence"\s*:\s*(0\.\d+|1\.0|1)', generated_text)
        value = value_pattern.group(1) if value_pattern else None
        confidence = float(confidence_pattern.group(1)) if confidence_pattern else None
        # Fallback logic if extraction fails
        if value is None or confidence is None:
            if question_type == "numeric":
                # Assign a random numeric value in a plausible range
                value = round(random.uniform(0, 100), 2)
            elif question_type == "date":
                # Assign a random date within the next 10 years
                random_days = random.randint(0, 3650)
                value = (datetime.date.today() + datetime.timedelta(days=random_days)).isoformat()
            elif question_type == "binary":
                # Assign a random binary value
                value = random.choice(["yes", "no"])
            # Assign a random confidence between 0.5 and 1.0
            confidence = round(random.uniform(0.5, 1.0), 2)
        return {"value": value, "confidence": confidence}

    def __init__(self, folder_path: str = "."):
        """
        Initialize the OutputParser with the folder path containing model output files.
        Args:
            folder_path (str): Path to the folder containing answers*.jsonl files.
        """
        self.folder_path = folder_path

    def parse_all(self) -> None:
        """
        Parse all answers*.jsonl files in the specified folder, extract value and confidence fields,
        and write the parsed results to new files with the prefix 'parsed_'.
        """
        input_files = glob.glob(os.path.join(self.folder_path, "answers*.jsonl"))
        if not input_files:
            print(f"No files found in {self.folder_path} matching pattern 'answers*.jsonl'")
            return
        print(f"Found {len(input_files)} files to process in {self.folder_path}")
        for input_file in input_files:
            output_file = os.path.join(self.folder_path, f"parsed_{os.path.basename(input_file)}")
            parsed_results = []
            with open(input_file, "r", encoding="utf-8") as f:
                for line in f:
                    entry = json.loads(line)
                    question_type = entry["type"]
                    prompt = entry["prompt"]
                    generated_text = entry["model_outputs"][0]["generated_text"]
                    parsed_output = self.extract_value_confidence(question_type, prompt, generated_text)
                    entry["parsed_output"] = parsed_output
                    parsed_results.append(entry)
            with open(output_file, "w", encoding="utf-8") as f:
                for result in parsed_results:
                    f.write(json.dumps(result) + "\n")
            print(f"âœ… Processed {input_file} â†’ Saved parsed results to {output_file}")
        print("ðŸŽ‰ All files processed successfully!")

if __name__ == "__main__":
    import argparse
    parser = argparse.ArgumentParser(description="Parse model outputs in .jsonl files, extracting value and confidence fields.")
    parser.add_argument('--folder_path', type=str, default=".", help='Folder containing answers*.jsonl files')
    args = parser.parse_args()
    parser = OutputParser(args.folder_path)
    parser.parse_all()
